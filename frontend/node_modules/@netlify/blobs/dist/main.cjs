"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  Blobs: () => Blobs
});
module.exports = __toCommonJS(main_exports);
var import_node_fs = require("fs");
var import_promises = require("fs/promises");
var import_node_stream = require("stream");

// node_modules/p-map/index.js
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve, reject_) => {
    if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = /* @__PURE__ */ new Map();
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === void 0 ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const reject = (reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
    };
    if (signal) {
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    const next = async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve(result);
            return;
          }
          const pureResult = [];
          for (const [index2, value] of result.entries()) {
            if (skippedIndexesMap.get(index2) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index, value);
          }
          result[index] = value;
          resolvingCount--;
          await next();
        } catch (error) {
          if (stopOnError) {
            reject(error);
          } else {
            errors.push(error);
            resolvingCount--;
            try {
              await next();
            } catch (error2) {
              reject(error2);
            }
          }
        }
      })();
    };
    (async () => {
      for (let index = 0; index < concurrency; index++) {
        try {
          await next();
        } catch (error) {
          reject(error);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
var pMapSkip = Symbol("skip");

// src/retry.ts
var DEFAULT_RETRY_DELAY = 5e3;
var MIN_RETRY_DELAY = 1e3;
var MAX_RETRY = 5;
var RATE_LIMIT_HEADER = "X-RateLimit-Reset";
var fetchAndRetry = async (fetcher, url, options, attemptsLeft = MAX_RETRY) => {
  try {
    const res = await fetcher(url, options);
    if (attemptsLeft > 0 && (res.status === 429 || res.status >= 500)) {
      const delay = getDelay(res.headers.get(RATE_LIMIT_HEADER));
      await sleep(delay);
      return fetchAndRetry(fetcher, url, options, attemptsLeft - 1);
    }
    return res;
  } catch (error) {
    if (attemptsLeft === 0) {
      throw error;
    }
    const delay = getDelay();
    await sleep(delay);
    return fetchAndRetry(fetcher, url, options, attemptsLeft - 1);
  }
};
var getDelay = (rateLimitReset) => {
  if (!rateLimitReset) {
    return DEFAULT_RETRY_DELAY;
  }
  return Math.max(Number(rateLimitReset) * 1e3 - Date.now(), MIN_RETRY_DELAY);
};
var sleep = (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});

// src/main.ts
var EXPIRY_HEADER = "x-nf-expires-at";
var Blobs = class _Blobs {
  constructor({ authentication, context, fetcher, siteID }) {
    this.context = context ?? "production";
    this.fetcher = fetcher ?? globalThis.fetch;
    this.siteID = siteID;
    if ("contextURL" in authentication) {
      this.authentication = authentication;
    } else {
      this.authentication = {
        apiURL: authentication.apiURL ?? "https://api.netlify.com",
        token: authentication.token
      };
    }
    if (fetcher) {
      this.fetcher = fetcher;
    } else if (globalThis.fetch) {
      this.fetcher = globalThis.fetch;
    } else {
      throw new Error("You must specify a fetch-compatible `fetcher` parameter when `fetch` is not available globally");
    }
  }
  async getFinalRequest(key, method) {
    const encodedKey = encodeURIComponent(key);
    if ("contextURL" in this.authentication) {
      return {
        headers: {
          authorization: `Bearer ${this.authentication.token}`
        },
        url: `${this.authentication.contextURL}/${this.siteID}/${this.context}/${encodedKey}`
      };
    }
    const apiURL = `${this.authentication.apiURL}/api/v1/sites/${this.siteID}/blobs/${encodedKey}?context=${this.context}`;
    const headers = { authorization: `Bearer ${this.authentication.token}` };
    const res = await this.fetcher(apiURL, { headers, method });
    if (res.status !== 200) {
      throw new Error(`${method} operation has failed: API returned a ${res.status} response`);
    }
    const { url } = await res.json();
    return {
      url
    };
  }
  static getExpirationHeaders(expiration) {
    if (typeof expiration === "number") {
      return {
        [EXPIRY_HEADER]: (Date.now() + expiration).toString()
      };
    }
    if (expiration instanceof Date) {
      return {
        [EXPIRY_HEADER]: expiration.getTime().toString()
      };
    }
    if (expiration === void 0) {
      return {};
    }
    throw new TypeError(`'expiration' value must be a number or a Date, ${typeof expiration} found.`);
  }
  isConfigured() {
    return Boolean(this.authentication?.token) && Boolean(this.siteID);
  }
  async makeStoreRequest(key, method, extraHeaders, body) {
    if (!this.isConfigured()) {
      throw new Error("The blob store is unavailable because it's missing required configuration properties");
    }
    const { headers: baseHeaders = {}, url } = await this.getFinalRequest(key, method);
    const headers = {
      ...baseHeaders,
      ...extraHeaders
    };
    if (method === "put" /* Put */) {
      headers["cache-control"] = "max-age=0, stale-while-revalidate=60";
    }
    const options = {
      body,
      headers,
      method
    };
    if (body instanceof ReadableStream) {
      options.duplex = "half";
    }
    const res = await fetchAndRetry(this.fetcher, url, options);
    if (res.status === 404 && method === "get" /* Get */) {
      return null;
    }
    if (res.status !== 200) {
      throw new Error(`${method} operation has failed: store returned a ${res.status} response`);
    }
    return res;
  }
  async delete(key) {
    await this.makeStoreRequest(key, "delete" /* Delete */);
  }
  async get(key, options) {
    const { type } = options ?? {};
    const res = await this.makeStoreRequest(key, "get" /* Get */);
    const expiration = res?.headers.get(EXPIRY_HEADER);
    if (typeof expiration === "string") {
      const expirationTS = Number.parseInt(expiration);
      if (!Number.isNaN(expirationTS) && expirationTS <= Date.now()) {
        return null;
      }
    }
    if (res === null) {
      return res;
    }
    if (type === void 0 || type === "text") {
      return res.text();
    }
    if (type === "arrayBuffer") {
      return res.arrayBuffer();
    }
    if (type === "blob") {
      return res.blob();
    }
    if (type === "json") {
      return res.json();
    }
    if (type === "stream") {
      return res.body;
    }
    throw new Error(`Invalid 'type' property: ${type}. Expected: arrayBuffer, blob, json, stream, or text.`);
  }
  async set(key, data, { expiration } = {}) {
    const headers = _Blobs.getExpirationHeaders(expiration);
    await this.makeStoreRequest(key, "put" /* Put */, headers, data);
  }
  async setFile(key, path, { expiration } = {}) {
    const { size } = await (0, import_promises.stat)(path);
    const file = import_node_stream.Readable.toWeb((0, import_node_fs.createReadStream)(path));
    const headers = {
      ..._Blobs.getExpirationHeaders(expiration),
      "content-length": size.toString()
    };
    await this.makeStoreRequest(key, "put" /* Put */, headers, file);
  }
  setFiles(files, { concurrency = 5 } = {}) {
    return pMap(files, ({ key, path, ...options }) => this.setFile(key, path, options), { concurrency });
  }
  async setJSON(key, data, { expiration } = {}) {
    const payload = JSON.stringify(data);
    const headers = {
      ..._Blobs.getExpirationHeaders(expiration),
      "content-type": "application/json"
    };
    await this.makeStoreRequest(key, "put" /* Put */, headers, payload);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Blobs
});
